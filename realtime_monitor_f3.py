# -*- coding: utf-8 -*-
"""
Created on Mon Jan 30 10:57:43 2023

The "function 3" written be Zhenghan in "realtime_monitoring.py" is improved,
 and saved seperately from the moduel "XEM7305_photon_counter.py".

Please put this file together with the file "XEM7305_photon_counter.py".

Just run this file will get the real time monitoring to "differentiate lock-in count plot".

@author: Seigen
      qingyuan.tian@oist.jp, tianqingyuan68@gmail.com
"""



#%% To differentiate the lock-in count plot generated by function 2  (function 3)

import time
import matplotlib.pyplot as plt
import XEM7305_photon_counter

dev = XEM7305_photon_counter.XEM7305_photon_counter()

dev.counting_period =1e5
dev.lockin_up_period = 1e5*512
dev.lockin_down_period = 1e5*512

PIPEOUT_SIZE = 1024 # const
NUM_FRAMES = 10000 # total measuring time equals to NUM_FRAMES * PIPEOUT_SIZE * counting_period

buff = [ bytearray(4*PIPEOUT_SIZE) for _ in range(2)]
ia_out = [ [0] for _ in range(2)]

from matplotlib.animation import FuncAnimation
fig, ax = plt.subplots()
y = []
x = []
pre_value = 0

def animate(k,x,y):
    global pre_value
    
    dev.pipe_out(buff[1])

    cur_value = int.from_bytes(buff[1][(PIPEOUT_SIZE-1)*4:PIPEOUT_SIZE*4], "little") #Zhenghun used the first value in a 1024 length array. But I think the last one is better for real time monitoring, because it is the newest. Seigen.
    
    # under flow processing: hard-coding. Might have better solution.
    if (dev.lock_in == 1 and cur_value > 4200000000): 
        cur_value = cur_value - 4294967296
    
    # over flow processing: lock-in count shold not over-flow.
    
    ia_out[1][0] = cur_value
    pre_value = cur_value #pre_value updated
    
    t = k*1024*dev.counting_period*1e-9
    y.append(ia_out[1][0]-ia_out[0][0])
    x.append(t)
    ia_out[0][0] = ia_out[1][0] #pre_value updated
    
    
    x = x[-1000:] # to set the number of data points in every frame 
    y = y[-1000:]
    
    ax.clear()
    line, = ax.plot(x, y)
    ax.set_ylabel('Count gained per Lock-in period')
    ax.set_xlabel('timeline/s')

    return line, 
    
dev.start_lockin_count() 
# time.sleep(0.1024) # I don't think we need sleep here. But if real experiment needs some sleep time, un-comment it. Seigen.
ani = FuncAnimation(fig, animate, frames=NUM_FRAMES, interval=0,fargs=(x,y), repeat=False) # set interval to 0, let pipeOut() control the timing automatically.
plt.show()